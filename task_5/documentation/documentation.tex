\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% ToDo: add info
\newcommand{\Aufgabe}{Aufgabe 1: Wörter aufräumen} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamId}{?????} % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{?????}
\newcommand{\Namen}{Katharina Libner , Christopher Besch}
 
% header and footer
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% title position
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% for match commands and symbols
\usepackage{amsmath}
\usepackage{amssymb}

% for images
\usepackage{graphicx}

% for algorithms
\usepackage{algpseudocode}

% for source code
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  keywordstyle=\color{blue},commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},rulecolor=\color{black},
  basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
  captionpos=b, % sets the caption-position to bottom
  keepspaces=true, % keeps spaces in text
  numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
  showtabs=false, stepnumber=2, tabsize=2, title=\lstname
}
\lstdefinelanguage{JavaScript}{ % JavaScript is the only non-predefined language
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

% these packages must be loaded last
\usepackage{hyperref}
\usepackage{cleveref}

% python source code setup
\lstset{
    language=Python,
    basicstyle=\small\sffamily,
    numbers=left,
    numberstyle=\tiny,
    frame=tb,
    tabsize=4,
    columns=fixed,
    showstringspaces=false,
    showtabs=false,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue}
}

% title
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamId \\\\
	    \LARGE Team-Name: \LARGE \TeamName \\\\
	    \LARGE Bearbeiter/-innen dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Lösungsidee}
\label{sec:loe}
% Die Idee der Lösung sollte hieraus vollkommen ersichtlich werden, ohne dass auf die eigentliche Implementierung Bezug genommen wird.

Eingegeben werden Schüler und Pakete, die mit 1 anfangend durchnummeriert sind.
Jeder Schüler hat drei Wünsche, die jeweils einem der gegebenen Pakete entsprechen.
Nun ist es die Aufgabe des Programmes, die/eine optimale Anordnung der Pakete und Schüler zu finden.
Die Ausführung dieser Aufgabe lässt sich in drei Subaufgaben einteilen:
\begin{enumerate}
    \item Eine Anordnung ist besser als eine andere, wenn mehr Schüler ihren ersten Wunsch bekommen haben, die anderen beiden Wünsche sind hierbei irrelevant.
    Zuerst können alle Pakete, die nur von einem Schüler am meisten (erster Wunsch) gewünscht werden, zugeteilt werden.
    Das Gleiche kann für die anderen Wünsche durchgeführt werde.
    (Jeder einzelne Wunsch wird im Folgenden \glqq aktueller Wunsch\grqq{} genannt.)
    Hierbei ist allerdings zu beachten, dass die Pakete, die von mindestens einem Schüler als ein wichtigerer Wunsch als der aktuelle gewählt wurden, ausgenommen werden müssen.
    Wenn nun ein Schüler einem Paket zugeteilt worden ist, überprüft das Programm, ob nun ein Paket, dass von den zugeteiltem Schüler als wichtigerer Wunsch gewählt wurde, nur noch von einem einzelnen Schüler gewünscht wird, ist dies der Fall, wird dieses Paket ebenfalls zugeordnet.
    Diese Überprüfung wird immer für alle Zuteilungen durchgeführt.
    \item Nun liegen nur noch Pakete vor, die von niemandem gewünscht werden, und solche, die von mehreren gewünscht werden.
    Es werden alle Pakete, die von mehren Schülern gewünscht worden, durchgegangen. Hierbei werden erst alle ersten und danach alle unwichtigeren Wünsche untersucht.
    Für alle diese Pakete wird willkürlich ein Wünscher, ein Schüler, der sich das Paket wünscht, ausgewählt.
    \item Es bleiben ausschließlich Pakete übrig die von niemandem, der noch nicht zugeteilt wurde, gewünscht werden. Diese werden komplett willkürlich auf die verbleibenden Schüler verteilt.
\end{enumerate}

\section{Umsetzung}
% Hier wird kurz erläutert, wie die Lösungsidee im Programm tatsächlich umgesetzt wurde. Hier können auch Implementierungsdetails erwähnt werden.

Die Lösungsidee wird in Python implementiert.
Zuerst werden die Pakete aus der Datei gelesen und in Student (sie enthalten die Nummer des Schülers und dessen Wünsche) und Package (sie enthalten die Nummer des Paketes und die Nummern aufgeschlüsselt nach der Wichtigkeit des Wünsche aller Schüler, die sich das Paket wünschen.) Objekte konvertiert.
Es werden zwei Dictionaries verwendet, eins enthält alle Schüler Objekte und eins alle Schüler Objekte.
Um die rohen Daten aus der Datei in diese beiden Dictionaries zu speichern wird die Funktion load\_students\_and\_packages verwendet.

Diese Dictionaries werden in einem Selection Objekt gespeichert.
Dieses Objekt enthält die in \autoref{sec:loe} beschriebenen Methoden, assign\_all\_cleanly, assign\_all\_uncleanly und assign\_all\_dirtily in der richtigen Anordnung.
Zudem enthält es ein Dictionary (assigned\_students), dieses enthält die Zuordnungen der Schüler mit den Paketen.
assigned\_students wird somit von den genannten Methoden angepasst.
Die in \autoref{sec:loe} genannte Überprüfung wird mithilfe zweier rekursiver Methoden umgesetzt, assign\_package\_if\_possible und resolve\_after\_assignment.
assign\_package\_if\_possible versucht ein Paket zuzuteilen, ohne einem Schüler dessen Wunsch zu nehmen, wenn dieser genauso wichtig oder wichtiger ist als der aktuelle.
resolve\_after\_assignment führt die Überprüfung rekursiv aus, die Methode führt sich selber für alle wichtigeren Wünschen aus und führt assign\_package\_if\_possible aus, um ein Paket einem Schüler zuzuordnen.
assign\_package\_if\_possible ruft wiederum resolve\_after\_assignment auf, um weitere Pakete zu überprüfen.

\section{Beispiele}
% Genügend Beispiele einbinden! Die Beispiele von der BwInf-Webseite sollten hier diskutiert werden, aber auch eigene Beispiele sind sehr gut – besonders wenn sie Spezialfälle abdecken. Aber bitte nicht 30 Seiten Programmausgabe hier einfügen!

Nun wird das Programm mit allen Beispieldateien ausgeführt.

\paragraph{raetsel0.txt}
Es wird das Ergebnis \glqq oh je, was für eine arbeit!\grqq{} ausgegeben.

Die Wörter wurden korrekt ersetzt und unter Verwendung der Nicht-Wörtern zu einem sinnvollem Satz zusammengefügt.

\paragraph{raetsel1.txt}
Das Ergebnis ist \glqq Am Anfang wurde das Universum erschaffen.
Das machte viele Leute sehr wütend und wurde allenthalben als Schritt in die falsche Richtung angesehen.\grqq{}

Hier erkennt man, dass die Rekursion funktioniert, da das dritte Wort im Originaltext, \glqq \_\_\_\_e\grqq{}, durch \glqq Leute\grqq{} ersetzbar ist, allerdings muss \glqq Leute\grqq{} für das zehnte Wort, \glqq \_\_u\_\_\grqq{} verwendet werden.

\paragraph{raetsel2.txt}
\glqq Als Gregor Samsa eines Morgens aus unruhigen Träumen erwachte, fand er sich in seinem Bett zu einem ungeheueren Ungeziefer verwandelt.\grqq{}

Hier erlangt man keine neuen Erkenntnisse über das Programm.

\paragraph{raetsel3.txt}
\glqq Informatik ist die Wissenschaft von der systematischen Darstellung, Speicherung, Verarbeitung und Übertragung von Informationen, besonders der automatischen Verarbeitung mit Digitalrechnern.\grqq{}

\paragraph{raetsel4.txt}
\glqq Opa Jürgen blättert in einer Zeitschrift aus der Apotheke und findet ein Rätsel. Es ist eine Liste von Wörtern gegeben, die in die richtige Reihenfolge gebracht werden sollen, so dass sie eine lustige Geschichte ergeben. Leerzeichen und Satzzeichen sowie einige Buchstaben sind schon vorgegeben.\grqq{}

\paragraph{Eigenes Beispiel 1}
Die Beispieldatei sieht wie folgt aus:

\begin{itemize}
    \item[] !!!Das ...,,,,,ist,,,!!!!...! ein .,.,..,.tolles \_\_i\_\_iel!!!
    \item[] Beispiel
\end{itemize}

Mit dem Ergebnis \glqq !!!Das ...,,,,,ist,,,!!!!...! ein .,.,..,.tolles Beispiel!!!\grqq{}

Hier wird deutlich, dass das Programm kein Problem mit Wörtern ohne Lücken aufweist und ebenfalls Nicht-Wörter ganz am Anfang akzeptiert. Zudem wird deutlich, dass die Länge der Nicht-Wörter und deren Bestandteile (solange sie keine Buchstaben oder \glqq \_\grqq{} enthalten) irrelevant sind.

\paragraph{Eigenes Beispiel 2}
Dieses Beispiel ist \textbf{raetsel4.txt} mit einer kleinen Abänderung, ein Wort aus der Wörterbank fehlt, es kann also keine Lösung geben. Dies gibt das Programm korrekt aus, \glqq No solution could be found!\grqq{}.

\paragraph{Eigenes Beispiel 3}
Genau wie das zweite eigene Beispiel ist dieses eine Kopie von \textbf{raetsel4.txt} mit einer kleinen Abänderung, ein Wort aus der Wörterbank wurde abgeändert, \glqq gegeben\grqq{} wurde durch \glqq aaaaben\grqq{} ausgetauscht, es kann also keine Lösung geben. Dies gibt das Programm ebenfalls korrekt aus, \glqq No solution could be found!\grqq{}.

\section{Quellcode}
% Unwichtige Teile des Programms sollen hier nicht abgedruckt werden. Dieser Teil sollte nicht mehr als 2–3 Seiten umfassen, maximal 10.

Es folgt der wichtigste Teil des Programmes, die rekursive Funktion, mit gekürzten Kommentaren. Das komplette Programm mit ausführlichen Kommentaren findet sich in \textbf{main.py}.
\begin{lstlisting}
def replace_incomplete_words(words, word_bank):
    # there are no words left to be replaced -> break recursion
    if len(words) == 0:
        return []

    result = []

    # no blanks in the current word -> word is already complete
    if "_" not in words[0]:
        following_replacements = replace_incomplete_words(words[1:], word_bank)
        if following_replacements is not None:
            result = [words[0]] + following_replacements
            hit = True
        else:
            hit = False
    else:
        replacement_indices = find_replacements(words[0], word_bank)

        # test every replacement
        hit = False
        for replacement_idx in replacement_indices:
            current_word_bank = word_bank.copy()
            replacement = current_word_bank.pop(replacement_idx)
            following_replacements = replace_incomplete_words(words[1:], current_word_bank)
            if following_replacements is not None:
                result = [replacement] + following_replacements
                hit = True
                break
    if hit:
        return result
    else:
        return None
\end{lstlisting}

\end{document}
